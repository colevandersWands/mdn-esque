// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

!function (e) { "object" == typeof exports && "object" == typeof module ? e(require("../../lib/codemirror")) : "function" == typeof define && define.amd ? define(["../../lib/codemirror"], e) : e(CodeMirror) }(function (Ce) { "use strict"; function Oe(e, t, r) { return /^(?:operator|sof|keyword c|case|new|export|default|[\[{}\(,;:]|=>)$/.test(t.lastType) || "quasi" == t.lastType && /\{\s*$/.test(e.string.slice(0, e.pos - (r || 0))) } Ce.defineMode("javascript", function (e, f) { var n, a, d = e.indentUnit, p = f.statementIndent, o = f.jsonld, c = f.json || o, s = f.typescript, l = f.wordCharacters || /[\w$\xa1-\uffff]/, u = function () { function e(e) { return { type: e, style: "keyword" } } var t = e("keyword a"), r = e("keyword b"), n = e("keyword c"), a = e("operator"), i = { type: "atom", style: "atom" }, o = { if: e("if"), while: t, with: t, else: r, do: r, try: r, finally: r, return: n, break: n, continue: n, new: e("new"), delete: n, throw: n, debugger: n, var: e("var"), const: e("var"), let: e("var"), function: e("function"), catch: e("catch"), for: e("for"), switch: e("switch"), case: e("case"), default: e("default"), in: a, typeof: a, instanceof: a, true: i, false: i, null: i, undefined: i, NaN: i, Infinity: i, this: e("this"), class: e("class"), super: e("atom"), yield: n, export: e("export"), import: e("import"), extends: n, await: n, async: e("async") }; if (s) { var c = { type: "variable", style: "variable-3" }, u = { interface: e("class"), implements: n, namespace: n, module: e("module"), enum: e("module"), type: e("type"), public: e("modifier"), private: e("modifier"), protected: e("modifier"), abstract: e("modifier"), as: a, string: c, number: c, boolean: c, any: c }; for (var l in u) o[l] = u[l] } return o }(), m = /[+\-*&%=<>!?|~^]/, v = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/; function y(e, t, r) { return n = e, a = r, t } function k(e, t) { var a, r = e.next(); if ('"' == r || "'" == r) return t.tokenize = (a = r, function (e, t) { var r, n = !1; if (o && "@" == e.peek() && e.match(v)) return t.tokenize = k, y("jsonld-keyword", "meta"); for (; null != (r = e.next()) && (r != a || n);)n = !n && "\\" == r; return n || (t.tokenize = k), y("string", "string") }), t.tokenize(e, t); if ("." == r && e.match(/^\d+(?:[eE][+\-]?\d+)?/)) return y("number", "number"); if ("." == r && e.match("..")) return y("spread", "meta"); if (/[\[\]{}\(\),;\:\.]/.test(r)) return y(r); if ("=" == r && e.eat(">")) return y("=>", "operator"); if ("0" == r && e.eat(/x/i)) return e.eatWhile(/[\da-f]/i), y("number", "number"); if ("0" == r && e.eat(/o/i)) return e.eatWhile(/[0-7]/i), y("number", "number"); if ("0" == r && e.eat(/b/i)) return e.eatWhile(/[01]/i), y("number", "number"); if (/\d/.test(r)) return e.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/), y("number", "number"); if ("/" == r) return e.eat("*") ? (t.tokenize = b)(e, t) : e.eat("/") ? (e.skipToEnd(), y("comment", "comment")) : Oe(e, t, 1) ? (function (e) { for (var t, r = !1, n = !1; null != (t = e.next());) { if (!r) { if ("/" == t && !n) return; "[" == t ? n = !0 : n && "]" == t && (n = !1) } r = !r && "\\" == t } }(e), e.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/), y("regexp", "string-2")) : (e.eatWhile(m), y("operator", "operator", e.current())); if ("`" == r) return (t.tokenize = x)(e, t); if ("#" == r) return e.skipToEnd(), y("error", "error"); if (m.test(r)) return ">" == r && t.lexical && ">" == t.lexical.type || e.eatWhile(m), y("operator", "operator", e.current()); if (l.test(r)) { e.eatWhile(l); var n = e.current(), i = u.propertyIsEnumerable(n) && u[n]; return i && "." != t.lastType ? y(i.type, i.style, n) : y("variable", "variable", n) } } function b(e, t) { for (var r, n = !1; r = e.next();) { if ("/" == r && n) { t.tokenize = k; break } n = "*" == r } return y("comment", "comment") } function x(e, t) { for (var r, n = !1; null != (r = e.next());) { if (!n && ("`" == r || "$" == r && e.eat("{"))) { t.tokenize = k; break } n = !n && "\\" == r } return y("quasi", "string-2", e.current()) } var h = "([{}])"; function i(e, t) { t.fatArrowAt && (t.fatArrowAt = null); var r = e.string.indexOf("=>", e.start); if (!(r < 0)) { if (s) { var n = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(e.string.slice(e.start, r)); n && (r = n.index) } for (var a = 0, i = !1, o = r - 1; 0 <= o; --o) { var c = e.string.charAt(o), u = h.indexOf(c); if (0 <= u && u < 3) { if (!a) { ++o; break } if (0 == --a) { "(" == c && (i = !0); break } } else if (3 <= u && u < 6) ++a; else if (l.test(c)) i = !0; else { if (/["'\/]/.test(c)) return; if (i && !a) { ++o; break } } } i && !a && (t.fatArrowAt = o) } } var w = { atom: !0, number: !0, variable: !0, string: !0, regexp: !0, this: !0, "jsonld-keyword": !0 }; function g(e, t, r, n, a, i) { this.indented = e, this.column = t, this.type = r, this.prev = a, this.info = i, null != n && (this.align = n) } function j(e, t) { for (var r = e.localVars; r; r = r.next)if (r.name == t) return 1; for (var n = e.context; n; n = n.prev)for (r = n.vars; r; r = r.next)if (r.name == t) return 1 } var M = { state: null, column: null, marked: null, cc: null }; function V() { for (var e = arguments.length - 1; 0 <= e; e--)M.cc.push(arguments[e]) } function E() { return V.apply(null, arguments), !0 } function r(r) { function e(e) { for (var t = e; t; t = t.next)if (t.name == r) return 1 } var t = M.state; if (M.marked = "def", t.context) { if (e(t.localVars)) return; t.localVars = { name: r, next: t.localVars } } else { if (e(t.globalVars)) return; f.globalVars && (t.globalVars = { name: r, next: t.globalVars }) } } var t = { name: "this", next: { name: "arguments" } }; function I() { M.state.context = { prev: M.state.context, vars: M.state.localVars }, M.state.localVars = t } function z() { M.state.localVars = M.state.context.vars, M.state.context = M.state.context.prev } function A(n, a) { function e() { var e = M.state, t = e.indented; if ("stat" == e.lexical.type) t = e.lexical.indented; else for (var r = e.lexical; r && ")" == r.type && r.align; r = r.prev)t = r.indented; e.lexical = new g(t, M.stream.column(), n, null, e.lexical, a) } return e.lex = !0, e } function T() { var e = M.state; e.lexical.prev && (")" == e.lexical.type && (e.indented = e.lexical.indented), e.lexical = e.lexical.prev) } function $(r) { return function e(t) { return t == r ? E() : ";" == r ? V() : E(e) } } function q(e, t) { return "var" == e ? E(A("vardef", t.length), ce, $(";"), T) : "keyword a" == e ? E(A("form"), W, q, T) : "keyword b" == e ? E(A("form"), q, T) : "{" == e ? E(A("}"), ee, T) : ";" == e ? E() : "if" == e ? ("else" == M.state.lexical.info && M.state.cc[M.state.cc.length - 1] == T && M.state.cc.pop()(), E(A("form"), W, q, T, de)) : "function" == e ? E(be) : "for" == e ? E(A("form"), pe, q, T) : "variable" == e ? E(A("stat"), L) : "switch" == e ? E(A("form"), W, A("}", "switch"), $("{"), ee, T, T) : "case" == e ? E(C, $(":")) : "default" == e ? E($(":")) : "catch" == e ? E(A("form"), I, $("("), xe, $(")"), q, T, z) : "class" == e ? E(A("form"), we, T) : "export" == e ? E(A("stat"), Ve, T) : "import" == e ? E(A("stat"), Ie, T) : "module" == e ? E(A("form"), ue, A("}"), $("{"), ee, T, T) : "type" == e ? E(re, $("operator"), re, $(";")) : "async" == e ? E(q) : V(A("stat"), C, $(";"), T) } function C(e) { return P(e, !1) } function O(e) { return P(e, !0) } function W(e) { return "(" != e ? V() : E(A(")"), C, $(")"), T) } function P(e, t) { if (M.state.fatArrowAt == M.stream.start) { var r = t ? G : F; if ("(" == e) return E(I, A(")"), Z(ue, ")"), T, $("=>"), r, z); if ("variable" == e) return V(I, ue, $("=>"), r, z) } var n, a = t ? H : B; return w.hasOwnProperty(e) ? E(a) : "function" == e ? E(be, a) : "class" == e ? E(A("form"), he, T) : "keyword c" == e || "async" == e ? E(t ? N : S) : "(" == e ? E(A(")"), S, $(")"), T, a) : "operator" == e || "spread" == e ? E(t ? O : C) : "[" == e ? E(A("]"), qe, T, a) : "{" == e ? _(R, "}", null, a) : "quasi" == e ? V(U, a) : "new" == e ? E((n = t, function (e) { return "." == e ? E(n ? K : J) : V(n ? O : C) })) : E() } function S(e) { return e.match(/[;\}\)\],]/) ? V() : V(C) } function N(e) { return e.match(/[;\}\)\],]/) ? V() : V(O) } function B(e, t) { return "," == e ? E(C) : H(e, t, !1) } function H(e, t, r) { var n = 0 == r ? B : H, a = 0 == r ? C : O; return "=>" == e ? E(I, r ? G : F, z) : "operator" == e ? /\+\+|--/.test(t) ? E(n) : "?" == t ? E(C, $(":"), a) : E(a) : "quasi" == e ? V(U, n) : ";" != e ? "(" == e ? _(O, ")", "call", n) : "." == e ? E(Q, n) : "[" == e ? E(A("]"), S, $("]"), T, n) : void 0 : void 0 } function U(e, t) { return "quasi" != e ? V() : "${" != t.slice(t.length - 2) ? E(U) : E(C, D) } function D(e) { if ("}" == e) return M.marked = "string-2", M.state.tokenize = x, E(U) } function F(e) { return i(M.stream, M.state), V("{" == e ? q : C) } function G(e) { return i(M.stream, M.state), V("{" == e ? q : O) } function J(e, t) { if ("target" == t) return M.marked = "keyword", E(B) } function K(e, t) { if ("target" == t) return M.marked = "keyword", E(H) } function L(e) { return ":" == e ? E(T, q) : V(B, $(";"), T) } function Q(e) { if ("variable" == e) return M.marked = "property", E() } function R(e, t) { return "async" == e ? (M.marked = "property", E(R)) : "variable" == e || "keyword" == M.style ? (M.marked = "property", E("get" == t || "set" == t ? X : Y)) : "number" == e || "string" == e ? (M.marked = o ? "property" : M.style + " property", E(Y)) : "jsonld-keyword" == e ? E(Y) : "modifier" == e ? E(R) : "[" == e ? E(C, $("]"), Y) : "spread" == e ? E(C) : ":" == e ? V(Y) : void 0 } function X(e) { return "variable" != e ? V(Y) : (M.marked = "property", E(be)) } function Y(e) { return ":" == e ? E(O) : "(" == e ? V(be) : void 0 } function Z(n, a, i) { function o(e, t) { if (i ? -1 < i.indexOf(e) : "," == e) { var r = M.state.lexical; return "call" == r.info && (r.pos = (r.pos || 0) + 1), E(function (e, t) { return e == a || t == a ? V() : V(n) }, o) } return e == a || t == a ? E() : E($(a)) } return function (e, t) { return e == a || t == a ? E() : V(n, o) } } function _(e, t, r) { for (var n = 3; n < arguments.length; n++)M.cc.push(arguments[n]); return E(A(t, r), Z(e, t), T) } function ee(e) { return "}" == e ? E() : V(q, ee) } function te(e, t) { if (s) { if (":" == e) return E(re); if ("?" == t) return E(te) } } function re(e) { return "variable" == e ? (M.marked = "variable-3", E(oe)) : "string" == e || "number" == e || "atom" == e ? E(oe) : "{" == e ? E(A("}"), Z(ae, "}", ",;"), T) : "(" == e ? E(Z(ie, ")"), ne) : void 0 } function ne(e) { if ("=>" == e) return E(re) } function ae(e, t) { return "variable" == e || "keyword" == M.style ? (M.marked = "property", E(ae)) : "?" == t ? E(ae) : ":" == e ? E(re) : void 0 } function ie(e) { return "variable" == e ? E(ie) : ":" == e ? E(re) : void 0 } function oe(e, t) { return "<" == t ? E(A(">"), Z(re, ">"), T, oe) : "|" == t || "." == e ? E(re) : "[" == e ? E($("]"), oe) : void 0 } function ce() { return V(ue, te, se, fe) } function ue(e, t) { return "modifier" == e ? E(ue) : "variable" == e ? (r(t), E()) : "spread" == e ? E(ue) : "[" == e ? _(ue, "]") : "{" == e ? _(le, "}") : void 0 } function le(e, t) { return "variable" != e || M.stream.match(/^\s*:/, !1) ? ("variable" == e && (M.marked = "property"), "spread" == e ? E(ue) : "}" == e ? V() : E($(":"), ue, se)) : (r(t), E(se)) } function se(e, t) { if ("=" == t) return E(O) } function fe(e) { if ("," == e) return E(ce) } function de(e, t) { if ("keyword b" == e && "else" == t) return E(A("form", "else"), q, T) } function pe(e) { if ("(" == e) return E(A(")"), me, $(")"), T) } function me(e) { return "var" == e ? E(ce, $(";"), ye) : ";" == e ? E(ye) : "variable" == e ? E(ve) : V(C, $(";"), ye) } function ve(e, t) { return "in" == t || "of" == t ? (M.marked = "keyword", E(C)) : E(B, ye) } function ye(e, t) { return ";" == e ? E(ke) : "in" == t || "of" == t ? (M.marked = "keyword", E(C)) : V(C, $(";"), ke) } function ke(e) { ")" != e && E(C) } function be(e, t) { return "*" == t ? (M.marked = "keyword", E(be)) : "variable" == e ? (r(t), E(be)) : "(" == e ? E(I, A(")"), Z(xe, ")"), T, te, q, z) : void 0 } function xe(e) { return "spread" == e ? E(xe) : V(ue, te, se) } function he(e, t) { return ("variable" == e ? we : ge)(e, t) } function we(e, t) { if ("variable" == e) return r(t), E(ge) } function ge(e, t) { return "extends" == t || "implements" == t || s && "," == e ? E(s ? re : C, ge) : "{" == e ? E(A("}"), je, T) : void 0 } function je(e, t) { return "variable" == e || "keyword" == M.style ? ("async" == t || "static" == t || "get" == t || "set" == t || s && ("public" == t || "private" == t || "protected" == t || "readonly" == t || "abstract" == t)) && M.stream.match(/^\s+[\w$\xa1-\uffff]/, !1) ? (M.marked = "keyword", E(je)) : (M.marked = "property", E(s ? Me : be, je)) : "[" == e ? E(C, $("]"), s ? Me : be, je) : "*" == t ? (M.marked = "keyword", E(je)) : ";" == e ? E(je) : "}" == e ? E() : void 0 } function Me(e, t) { return "?" == t ? E(Me) : ":" == e ? E(re, se) : V(be) } function Ve(e, t) { return "*" == t ? (M.marked = "keyword", E($e, $(";"))) : "default" == t ? (M.marked = "keyword", E(C, $(";"))) : "{" == e ? E(Z(Ee, "}"), $e, $(";")) : V(q) } function Ee(e, t) { return "as" == t ? (M.marked = "keyword", E($("variable"))) : "variable" == e ? V(O, Ee) : void 0 } function Ie(e) { return "string" == e ? E() : V(ze, Ae, $e) } function ze(e, t) { return "{" == e ? _(ze, "}") : ("variable" == e && r(t), "*" == t && (M.marked = "keyword"), E(Te)) } function Ae(e) { if ("," == e) return E(ze, Ae) } function Te(e, t) { if ("as" == t) return M.marked = "keyword", E(ze) } function $e(e, t) { if ("from" == t) return M.marked = "keyword", E(C) } function qe(e) { return "]" == e ? E() : V(Z(O, "]")) } return T.lex = !0, { startState: function (e) { var t = { tokenize: k, lastType: "sof", cc: [], lexical: new g((e || 0) - d, 0, "block", !1), localVars: f.localVars, context: f.localVars && { vars: f.localVars }, indented: e || 0 }; return f.globalVars && "object" == typeof f.globalVars && (t.globalVars = f.globalVars), t }, token: function (e, t) { if (e.sol() && (t.lexical.hasOwnProperty("align") || (t.lexical.align = !1), t.indented = e.indentation(), i(e, t)), t.tokenize != b && e.eatSpace()) return null; var r = t.tokenize(e, t); return "comment" == n ? r : (t.lastType = "operator" != n || "++" != a && "--" != a ? n : "incdec", function (e, t, r, n, a) { var i = e.cc; for (M.state = e, M.stream = a, M.marked = null, M.cc = i, M.style = t, e.lexical.hasOwnProperty("align") || (e.lexical.align = !0); ;) { if ((i.length ? i.pop() : c ? C : q)(r, n)) { for (; i.length && i[i.length - 1].lex;)i.pop()(); return M.marked ? M.marked : "variable" == r && j(e, n) ? "variable-2" : t } } }(t, r, n, a, e)) }, indent: function (e, t) { if (e.tokenize == b) return Ce.Pass; if (e.tokenize != k) return 0; var r, n = t && t.charAt(0), a = e.lexical; if (!/^\s*else\b/.test(t)) for (var i = e.cc.length - 1; 0 <= i; --i) { var o = e.cc[i]; if (o == T) a = a.prev; else if (o != de) break } for (; ("stat" == a.type || "form" == a.type) && ("}" == n || (r = e.cc[e.cc.length - 1]) && (r == B || r == H) && !/^[,\.=+\-*:?[\(]/.test(t));)a = a.prev; p && ")" == a.type && "stat" == a.prev.type && (a = a.prev); var c, u, l = a.type, s = n == l; return "vardef" == l ? a.indented + ("operator" == e.lastType || "," == e.lastType ? a.info + 1 : 0) : "form" == l && "{" == n ? a.indented : "form" == l ? a.indented + d : "stat" == l ? a.indented + (u = t, "operator" == (c = e).lastType || "," == c.lastType || m.test(u.charAt(0)) || /[,.]/.test(u.charAt(0)) ? p || d : 0) : "switch" != a.info || s || 0 == f.doubleIndentSwitch ? a.align ? a.column + (s ? 0 : 1) : a.indented + (s ? 0 : d) : a.indented + (/^(?:case|default)\b/.test(t) ? d : 2 * d) }, electricInput: /^\s*(?:case .*?:|default:|\{|\})$/, blockCommentStart: c ? null : "/*", blockCommentEnd: c ? null : "*/", lineComment: c ? null : "//", fold: "brace", closeBrackets: "()[]{}''\"\"``", helperType: c ? "json" : "javascript", jsonldMode: o, jsonMode: c, expressionAllowed: Oe, skipExpression: function (e) { var t = e.cc[e.cc.length - 1]; t != C && t != O || e.cc.pop() } } }), Ce.registerHelper("wordChars", "javascript", /[\w$]/), Ce.defineMIME("text/javascript", "javascript"), Ce.defineMIME("text/ecmascript", "javascript"), Ce.defineMIME("application/javascript", "javascript"), Ce.defineMIME("application/x-javascript", "javascript"), Ce.defineMIME("application/ecmascript", "javascript"), Ce.defineMIME("application/json", { name: "javascript", json: !0 }), Ce.defineMIME("application/x-json", { name: "javascript", json: !0 }), Ce.defineMIME("application/ld+json", { name: "javascript", jsonld: !0 }), Ce.defineMIME("text/typescript", { name: "javascript", typescript: !0 }), Ce.defineMIME("application/typescript", { name: "javascript", typescript: !0 }) });
